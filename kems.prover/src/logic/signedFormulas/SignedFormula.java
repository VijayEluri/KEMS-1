/*
 * Created on 15/10/2004
 *
 */
package logic.signedFormulas;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

import logic.formulas.Formula;
import util.EqualsUtil;

/**
 * Class the represents signed formulas.
 * 
 * @author Adolfo Gustavo Serra Seca Neto
 *  
 */
public class SignedFormula implements  Comparable<SignedFormula>{

    FormulaSign _sign;
    Formula _formula;

    protected SignedFormula(FormulaSign sign, Formula formula) {
        _sign = sign;
        _formula = formula;
    }

    /**
     * @return the formula
     */
    public Formula getFormula() {
        return _formula;
    }

    /**
     * @return the sign
     */
    public FormulaSign getSign() {
        return _sign;
    }

    /** generates a string similar to the string generated by the toString method applied 
     * to an instance of this class.
     * @param fs
     * @param f
     * @return
     */
    public static String toString(FormulaSign fs, Formula f) {
        return fs.toString() + " " + f.toString();
    }

    /*
     * (non-Javadoc)
     * 
     * @see java.lang.Object#toString()
     */
    public String toString() {
        return toString(_sign, _formula);
    }

    /* (non-Javadoc)
     * @see java.lang.Object#equals(java.lang.Object)
     */
    public boolean equals(Object aThat) {
        if (this == aThat)
            return true;
        // use instanceof instead of getClass here for two reasons
        // 1. if need be, it can match any supertype, and not just one class;
        // 2. it renders an explict check for "that == null" redundant, since
        // it does the check for null already - "null instanceof [type]" always
        // returns false. (See Effective Java by Joshua Bloch.)
        if (!(aThat instanceof SignedFormula))
            return false;
        // Alternative to the above line :
        // if ( aThat == null || aThat.getClass() != this.getClass() ) return
        // false;

        // cast to native object is now safe
        SignedFormula that = (SignedFormula) aThat;

        // now a proper field-by-field evaluation can be made
        return EqualsUtil.areEqual(this._sign, that._sign)
                && EqualsUtil.areEqual(this._formula, that._formula);
    }
    
    
    @Override
    public int hashCode() {
    	return this.toString().hashCode();
    }
//    /*
//     * (non-Javadoc)
//     * 
//     * @see java.lang.Object#hashCode()
//     */
//    public int hashCode() {
//    	
//    	
//        int result = HashCodeUtil.SEED;
//        result = HashCodeUtil.hash(result, _sign);
//    	System.out.println("USE OF SIGNED FORMULA HASH CODE 1: "+ this + "  "+ result);
//        result = HashCodeUtil.hash(result, _formula);
//    	System.out.println("USE OF SIGNED FORMULA HASH CODE 2: "+ this + "  "+ result);
//        
//    	System.out.println("USE OF SIGNED FORMULA HASH CODE final: "+ this + "  "+ result);
//        
//        return result;
//    }


	public int compareTo(SignedFormula arg0) {
		return toString().compareTo(arg0.toString());
	}

	/**
	 * Retorna o grau de consistência de uma fórmula
	 * */
	public int getGrauConsistencia(){
		return grauConsistencia(_formula.toString());
	}

	/**
	 * Retorna o grau de consistência
	 * */
	private int grauConsistencia(String frase){
		// .{1,2} -  pois pode ser uma fórmula do tipo: !(A&!A)
		// ou do tipo: !(A1&!A1)
		return grauConsistencia("!\\(.{1,2}&!.{1,2}\\)", frase);
	}
	
	/**
	 * Retorna o grau de consistência
	 * */
	private int grauConsistencia(String ER, String frase){
		Pattern p = Pattern.compile(ER);
		Matcher m = p.matcher(frase);
		String formula = "";
		int cont = 0;
		while (m.find()) {
			try {
				formula = m.group();
				//System.out.println(formula+ " \ti:" + m.start()+ " \tf:"+m.end());
				
				if (formulaValida(formula)) {
					cont++;
				}
				
			} catch (Exception err){
				//System.err.println("Erro - " + err.getMessage());
			}
		}
		
		return cont;
	}
	
	/**
	 * Retorna true se por exemplo para uma fórmula: !(X&!Y)
	 * se X e Y são iguais, como em !(A&!A), e falso se 
	 * X e Y são diferentes, como em: !(A&!B)
	 * <br /> Verifica também fórmulas do tipo: !(A1&!A1) 
	 * */
	private boolean formulaValida(String formula){
		if (formula.length() == 7) { // !(A&!A)
			char X = formula.charAt(2);
			char Y = formula.charAt(5);
			return X == Y;
		} else if (formula.length() == 9) { // !(A1&!A1)
			String X = formula.substring(2, 4);
			String Y = formula.substring(6, 8);
			return X.equals(Y);
		} else {
			return false;
		}
	}

}